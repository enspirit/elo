->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({name: "Alice"}, [:name]) == "Alice"; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({user: {name: "Bob"}}, [:user, :name]) == "Bob"; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({items: [10, 20, 30]}, [:items, 0]) == 10; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({items: [10, 20, 30]}, [:items, 2]) == 30; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({list: [{id: 1}, {id: 2}]}, [:list, 0, :id]) == 1; true) }.call(nil);
->(_) { (raise "Assertion failed" unless ((->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({name: "Alice"}, [:missing])).nil?; true) }.call(nil);
->(_) { (raise "Assertion failed" unless ((->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({name: "Alice"}, [:name, :child])).nil?; true) }.call(nil);
->(_) { (raise "Assertion failed" unless ((->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call(nil, [:x])).nil?; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, ps) { f = ->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }; ps.transform_values { |p| f.call(d, p) } }).call({a: 1, b: 2}, {x: [:a], y: [:b]}) == {x: 1, y: 2}; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, ps) { f = ->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }; ps.transform_values { |p| f.call(d, p) } }).call({foo: {bar: 10}}, {v: [:foo, :bar]}) == {v: 10}; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, ps) { f = ->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }; ps.transform_values { |p| f.call(d, p) } }).call({items: [1, 2, 3]}, {first: [:items, 0], last: [:items, 2]}) == {first: 1, last: 3}; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({x: 12}, ["x"]) == 12; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({x: 12}, ["x"]) == 12; true) }.call(nil);
->(_) { (raise "Assertion failed" unless (->(d, p) { p.reduce(d) { |cur, seg| break nil if cur.nil?; seg.is_a?(Integer) ? (cur.is_a?(Array) ? cur[seg] : nil) : (cur.is_a?(Hash) ? cur[seg.is_a?(String) ? seg.to_sym : seg] : nil) } }).call({user: {name: "Bob"}}, ["user", "name"]) == "Bob"; true) }.call(nil);
